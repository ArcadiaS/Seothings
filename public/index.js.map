{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/tslib/tslib.es6.js","webpack:///./tools/helpers.ts","webpack:///./constants.ts","webpack:///./tools/is.ts","webpack:///./tools/pub-sub.ts","webpack:///./observers/console.ts","webpack:///./tools/SonyA7R3.ts","webpack:///./models/observers.ts","webpack:///./observers/event.ts","webpack:///./observers/http.ts","webpack:///./observers/mutation.ts","webpack:///./observers/error.ts","webpack:///./observers/history.ts","webpack:///./observers/mouse.ts","webpack:///./index.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEO;AACP;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEO;AACP;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEO;AACP,mCAAmC,oCAAoC;AACvE;;AAEO;AACP;AACA;;AAEO;AACP,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;;AAEO;AACP,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,gBAAgB;AACzC;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEO;AACP,4BAA4B,sBAAsB;AAClD;AACA;AACA;;AAEO;AACP,iDAAiD,QAAQ;AACzD,wCAAwC,QAAQ;AAChD,wDAAwD,QAAQ;AAChE;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA,iBAAiB,sFAAsF,aAAa,EAAE;AACtH,sBAAsB,gCAAgC,qCAAqC,0CAA0C,EAAE,EAAE,GAAG;AAC5I,2BAA2B,MAAM,eAAe,EAAE,YAAY,oBAAoB,EAAE;AACpF,sBAAsB,oGAAoG;AAC1H,6BAA6B,uBAAuB;AACpD,4BAA4B,wBAAwB;AACpD,2BAA2B,yDAAyD;AACpF;;AAEO;AACP;AACA,iBAAiB,4CAA4C,SAAS,EAAE,qDAAqD,aAAa,EAAE;AAC5I,yBAAyB,6BAA6B,oBAAoB,gDAAgD,gBAAgB,EAAE,KAAK;AACjJ;;AAEO;AACP;AACA;AACA,2GAA2G,sFAAsF,aAAa,EAAE;AAChN,sBAAsB,8BAA8B,gDAAgD,uDAAuD,EAAE,EAAE,GAAG;AAClK,4CAA4C,sCAAsC,UAAU,oBAAoB,EAAE,EAAE,UAAU;AAC9H;;AAEO;AACP,gCAAgC,uCAAuC,aAAa,EAAE,EAAE,OAAO,kBAAkB;AACjH;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,4CAA4C;AAC5C;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;;ACzNO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,yBAAyB,EAAE;AACtD;AACA;;;AC3FO;AACA;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;;AC9BO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjByC;AACP;AAClC,IAAI,uBAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,6CAA6C,QAAQ;AACrD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACc,mEAAe,EAAC;;;AC7C+B;AACF;AACb;AACA;AAC/C,IAAI,uBAAe;AACnB,IAAI,SAAS;AACb;AACA;AACA,0CAA0C,eAAe;AACzD,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,CAAC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA;AACA;AACA,YAAY,QAAQ;AACpB,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,SAAS;AACT;AACA;AACA,CAAC,CAAC,OAAe;AACF,6EAAe,EAAC;;;ACzDY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uBAAc;AAClB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,sCAAsC,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA,+CAA+C,WAAW;AAC1D;AACA,+EAA+E,4BAA4B,EAAE;AAC7G;AACA;AACA;AACA,CAAC;AACD,mBAAmB,uBAAc;AAClB,2DAAQ,EAAC;;;ACnEjB;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA,sCAAsC;AACtC,CAAC,4CAA4C;;;AClDD;AACc;AACjB;AACM;AACE;AACF;AAC/C,2BAA2B,cAAQ;AACnC;AACA;AACA;AACA;AACA,IAAI,mBAAa;AACjB,IAAI,SAAS;AACb;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA,0BAA0B,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,CAAC,QAAQ,GAAG,YAAY,iBAAiB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ,CAAC,QAAQ,GAAG,YAAY,iCAAiC;AACtF;AACA;AACA;AACA;AACA,0BAA0B,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,CAAC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA,aAAa;AACb;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC,CAAC,OAAe;AACF,uEAAa,EAAC;;;ACpJiC;AACe;AACpC;AACM;AACA;AACG;AAClD,IAAI,iBAAY;AAChB,IAAI,SAAS;AACb;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,CAAC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC,2BAA2B,QAAQ;AACnC;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA,wFAAwF,QAAQ;AAChG;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB,QAAQ,QAAQ;AAChB,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,OAAe;AACF,oEAAY,EAAC;;;AC/NgB;AACD;AACF;AACM;AACA;AACQ;AACvD,IAAI,6BAAoB,GAAG,cAAQ;AACnC;AACA;AACA;AACA;AACA,IAAI,4BAAmB;AACvB,IAAI,SAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B,wBAAwB,6BAAoB;AAC5C;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,wBAAwB,6BAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB,6BAAoB;AAC5C;AACA,0BAA0B,6BAAoB;AAC9C;AACA;AACA,0BAA0B,6BAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAQ;AAC5B;AACA,oBAAoB,cAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6BAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,0CAA0C,mBAAmB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,gBAAgB;AACnD;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,OAAe;AACF,mFAAmB,EAAC;;;ACjQS;AACgB;AACb;AACA;AACE;AACjD,IAAI,mBAAa;AACjB,IAAI,SAAS;AACb;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,CAAC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,CAAC,CAAC,OAAe;AACF,uEAAa,EAAC;;;ACtHK;AACqC;AACxB;AACI;AACnD,IAAI,uBAAe;AACnB,IAAI,SAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,uBAAuB,SAAS;AAChC,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB,QAAQ,QAAQ;AAChB,QAAQ,IAAI;AACZ;AACA;AACA;AACA,QAAQ,QAAQ;AAChB,QAAQ,QAAQ;AAChB,QAAQ,QAAQ;AAChB;AACA;AACA;AACA,CAAC,CAAC,OAAe;AACF,6EAAe,EAAC;;;ACzEa;AACK;AACS;AACX;AACA;AAC/C;AACA;AACA;AACA;AACA,IAAI,mBAAa;AACjB,IAAI,SAAS;AACb;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,0BAA0B,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,CAAC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC,aAAa;AACb;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC,CAAC,OAAe;AACF,uEAAa,EAAC;;;AC7EI;AACwB;AACX;AACI;AACJ;AACF;AACW;AACT;AACI;AACJ;AACN;AACxC,IAAI,qBAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC,qBAAqB,QAAQ,EAAE,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,QAAQ,CAAC,QAAQ,GAAG;AAC/C;AACA;AACA;AACA,0BAA0B,kBAAmB;AAC7C,sBAAsB,cAAY;AAClC,yBAAyB,iBAAe;AACxC,uBAAuB,eAAa;AACpC,uBAAuB,eAAa;AACpC,uBAAuB,eAAa;AACpC,yBAAyB,iBAAe;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,IAAI,uBAAuB,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA,aAAa;AACb,sBAAsB,cAAQ;AAC9B;AACA;AACA;AACA,CAAC;AACc,gGAAe,EAAC;AAC/B,IAAI,qBAAe","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export var _log = console.log.bind(null, '[Recorder]:');\r\nexport var _error = console.error.bind(null, '[Recorder]:');\r\nexport var _warn = console.warn.bind(null, '[Recorder]:');\r\nexport function _now() {\r\n    if (!window.performance)\r\n        return Date.now();\r\n    // if user change local time, performance.now() would work accurate still\r\n    return Math.floor(performance.now());\r\n}\r\nexport function _throttle(func, wait) {\r\n    if (wait === void 0) { wait = 100; }\r\n    var previous = _now();\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var now = _now();\r\n        var restTime = now - previous;\r\n        if (restTime >= wait) {\r\n            previous = now;\r\n            return func.apply(this, args);\r\n        }\r\n    };\r\n}\r\n// weak uuid\r\nexport function _newuuid() {\r\n    return Math.random()\r\n        .toString(16)\r\n        .split('.')[1];\r\n}\r\n/**\r\n * Wrap and replace a given method with a high-order function\r\n *\r\n * @param source The object that contains a method to be wrapped.\r\n * @param name The name of method to be wrapped\r\n * @param replacement The function that should be used to wrap the given method\r\n */\r\nexport function _replace(source, name, replacement) {\r\n    var original = source[name];\r\n    function doReplace() {\r\n        var wrapped = replacement(original);\r\n        wrapped.__recorder__ = true;\r\n        wrapped.__recorder_original__ = original;\r\n        source[name] = wrapped;\r\n    }\r\n    if (original) {\r\n        // if original func existed\r\n        if (!(name in source) || original.__recorder__)\r\n            return;\r\n        doReplace();\r\n        return;\r\n    }\r\n    else if (original === null || original === undefined) {\r\n        // such as window.onerror whose initial value would be null\r\n        // so just do the replacement\r\n        doReplace();\r\n        return;\r\n    }\r\n}\r\n/**\r\n * Reverse to original function\r\n * @param source The object that contains a method been wrapped.\r\n * @param name The name of method been wrapped.\r\n */\r\nexport function _recover(source, name) {\r\n    if (!(name in source) || !source[name].__recorder__)\r\n        return;\r\n    var __recorder_original__ = source[name].__recorder_original__;\r\n    source[name] = __recorder_original__;\r\n}\r\nexport function _parseURL(href) {\r\n    if (href === void 0) { href = location.href; }\r\n    var match = href.match(/^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\r\n    if (!match)\r\n        return {};\r\n    var query = match[6] || '';\r\n    var fragment = match[8] || '';\r\n    return {\r\n        protocol: match[2],\r\n        host: match[4],\r\n        path: match[5],\r\n        query: query,\r\n        fragment: fragment,\r\n        relative: match[5] + query + fragment\r\n    };\r\n}\r\nexport function _seralize(obj) {\r\n    return Object.keys(obj)\r\n        .map(function (k) { return k + \"=\" + obj[k]; })\r\n        .join('&');\r\n}\r\n","export var RECORDER_ID = 'recorder-id';\r\nexport var RECORDER_PRESET = {\r\n    mutation: true,\r\n    history: true,\r\n    error: {\r\n        jserror: true,\r\n        unhandledrejection: true\r\n    },\r\n    console: {\r\n        info: true,\r\n        error: true,\r\n        log: false,\r\n        warn: true,\r\n        debug: false\r\n    },\r\n    event: {\r\n        scroll: true,\r\n        resize: true,\r\n        form: true\r\n    },\r\n    http: {\r\n        xhr: true,\r\n        fetch: true,\r\n        beacon: true\r\n    },\r\n    mouse: {\r\n        click: true,\r\n        mousemove: false\r\n    },\r\n    maxTimeSpan: 120000 // max time span of trail\r\n};\r\n","export function isFunction(sth) {\r\n    return typeof sth === 'function';\r\n}\r\nexport function isErrorEvent(sth) {\r\n    return Object.prototype.toString.call(sth) === '[object ErrorEvent]';\r\n}\r\nexport function isError(sth) {\r\n    switch (Object.prototype.toString.call(sth)) {\r\n        case '[object Error]':\r\n            return true;\r\n        case '[object Exception]':\r\n            return true;\r\n        case '[object DOMException]':\r\n            return true;\r\n        default:\r\n            return sth instanceof Error;\r\n    }\r\n}\r\n","import { __read, __spread } from \"tslib\";\r\nimport { isFunction } from './is';\r\nvar EventDrivenable = /** @class */ (function () {\r\n    function EventDrivenable() {\r\n        var _this = this;\r\n        this.queues = new Map();\r\n        this.$on = function (hook, action) {\r\n            var queues = _this.queues;\r\n            var existingTasks = queues.get(hook) || [];\r\n            queues.set(hook, __spread(existingTasks, [action]));\r\n        };\r\n        this.$off = function (hook, thisAction) {\r\n            var Q = _this.queues.get(hook) || [];\r\n            if (!Q.length) {\r\n                return;\r\n            }\r\n            var index = Q.indexOf(thisAction);\r\n            if (index !== -1) {\r\n                Q.splice(index, 1);\r\n                _this.queues.set(hook, Q);\r\n            }\r\n        };\r\n        this.$emit = function (hook) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            var Q = _this.queues.get(hook) || [];\r\n            if (!Q.length) {\r\n                return;\r\n            }\r\n            try {\r\n                Q.forEach(function (action) {\r\n                    if (isFunction(action)) {\r\n                        action.apply(void 0, __spread(args));\r\n                    }\r\n                });\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n        };\r\n    }\r\n    return EventDrivenable;\r\n}());\r\nexport default EventDrivenable;\r\n","import { __assign, __extends, __read, __spread } from \"tslib\";\r\nimport { _replace, _recover, _log } from '../tools/helpers';\r\nimport { RECORDER_PRESET } from '../constants';\r\nimport EventDrivenable from '../tools/pub-sub';\r\nvar ConsoleObserver = /** @class */ (function (_super) {\r\n    __extends(ConsoleObserver, _super);\r\n    function ConsoleObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.consoleLevels = Object.keys(RECORDER_PRESET.console);\r\n        _this.options = RECORDER_PRESET.console;\r\n        if (typeof options === 'boolean' && options === false) {\r\n            return _this;\r\n        }\r\n        if (typeof options === 'object') {\r\n            _this.options = __assign(__assign({}, _this.options), options);\r\n        }\r\n        return _this;\r\n    }\r\n    ConsoleObserver.prototype.install = function () {\r\n        var _this = this;\r\n        var $emit = this.$emit;\r\n        this.consoleLevels.forEach(function (level) {\r\n            if (!_this.options[level])\r\n                return;\r\n            function consoleReplacement(originalConsoleFunc) {\r\n                return function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    if (!args.length)\r\n                        return;\r\n                    var record = {\r\n                        type: 'console',\r\n                        level: level,\r\n                        input: args\r\n                    };\r\n                    $emit('observed', record);\r\n                    if (originalConsoleFunc) {\r\n                        originalConsoleFunc.call.apply(originalConsoleFunc, __spread([console], args));\r\n                    }\r\n                };\r\n            }\r\n            _replace(console, level, consoleReplacement);\r\n        });\r\n        _log('console observer ready!');\r\n    };\r\n    ConsoleObserver.prototype.uninstall = function () {\r\n        var _this = this;\r\n        this.consoleLevels.forEach(function (level) {\r\n            if (!_this.options[level])\r\n                return;\r\n            _recover(console, level);\r\n        });\r\n    };\r\n    return ConsoleObserver;\r\n}(EventDrivenable));\r\nexport default ConsoleObserver;\r\n","import { RECORDER_ID } from '../constants';\r\n/**\r\n * SonyA7R3 is a camera with abilities list below:\r\n * @feature take snapshot for page\r\n * @feature buffer every node in document up in Map<node, id> format\r\n * @feature mark / unmark node with unique ID\r\n */\r\nvar SonyA7R3Camera = /** @class */ (function () {\r\n    function SonyA7R3Camera() {\r\n        var _this = this;\r\n        this.map = new Map();\r\n        this.inited = false;\r\n        this.id = 0; // self-increase id\r\n        this.buffer = function (ele) {\r\n            var recorderId = _this.map.get(ele) || _this.newId();\r\n            _this.map.set(ele, recorderId);\r\n            _this.mark(ele, recorderId);\r\n            return recorderId;\r\n        };\r\n        // if document have new node, use this method because that node may have childElement\r\n        this.bufferNewElement = function (ele) {\r\n            _this.buffer(ele);\r\n            if (ele.childElementCount) {\r\n                // element.children retun childElements without textNodes\r\n                Array.prototype.slice.call(ele.children).forEach(function (chEle) { return _this.bufferNewElement(chEle); });\r\n            }\r\n        };\r\n        // get recorderId from map by element\r\n        this.getRecordIdByElement = function (ele) {\r\n            return _this.map.get(ele);\r\n        };\r\n    }\r\n    SonyA7R3Camera.prototype.takeSnapshotForPage = function () {\r\n        var _this = this;\r\n        console.time('[Snapshot for page]');\r\n        // Buffer every element into the Map\r\n        // Note that textNodes wouldn't been included !!\r\n        Array.prototype.slice.call(document.querySelectorAll('*')).forEach(this.buffer);\r\n        this.latestSnapshot = document.documentElement.outerHTML;\r\n        // remove recorder-id from node\r\n        Array.prototype.slice.call(document.querySelectorAll('*')).forEach(function (node) {\r\n            _this.unmark(node);\r\n        });\r\n        console.timeEnd('[Snapshot for page]');\r\n        return this.latestSnapshot;\r\n    };\r\n    SonyA7R3Camera.prototype.newId = function () {\r\n        this.id += 1;\r\n        return this.id;\r\n    };\r\n    // mark recorderId on non-textnode\r\n    SonyA7R3Camera.prototype.mark = function (ele, id) {\r\n        ele.setAttribute(RECORDER_ID, id);\r\n    };\r\n    // remove recorderId on non-textnode\r\n    SonyA7R3Camera.prototype.unmark = function (ele, isDeep) {\r\n        var _this = this;\r\n        if (isDeep === void 0) { isDeep = false; }\r\n        var removeAttribute = ele.removeAttribute;\r\n        removeAttribute && ele.removeAttribute(RECORDER_ID);\r\n        if (isDeep && ele.childElementCount) {\r\n            Array.prototype.slice.call(ele.children).forEach(function (chEle) { return _this.unmark(chEle); });\r\n        }\r\n    };\r\n    return SonyA7R3Camera;\r\n}());\r\nvar SonyA7R3 = new SonyA7R3Camera();\r\nexport default SonyA7R3;\r\n","export var ConsoleLevels;\r\n(function (ConsoleLevels) {\r\n    ConsoleLevels[\"info\"] = \"info\";\r\n    ConsoleLevels[\"error\"] = \"error\";\r\n    ConsoleLevels[\"log\"] = \"log\";\r\n    ConsoleLevels[\"warn\"] = \"warn\";\r\n    ConsoleLevels[\"debug\"] = \"debug\";\r\n})(ConsoleLevels || (ConsoleLevels = {}));\r\nexport var ConsoleTypes;\r\n(function (ConsoleTypes) {\r\n    ConsoleTypes[\"console\"] = \"console\";\r\n})(ConsoleTypes || (ConsoleTypes = {}));\r\nexport var EventTypes;\r\n(function (EventTypes) {\r\n    EventTypes[\"scroll\"] = \"scroll\";\r\n    EventTypes[\"resize\"] = \"resize\";\r\n    EventTypes[\"form\"] = \"form\";\r\n})(EventTypes || (EventTypes = {}));\r\nexport var MouseTypes;\r\n(function (MouseTypes) {\r\n    MouseTypes[\"click\"] = \"click\";\r\n    MouseTypes[\"move\"] = \"move\";\r\n})(MouseTypes || (MouseTypes = {}));\r\nexport var HistoryTypes;\r\n(function (HistoryTypes) {\r\n    HistoryTypes[\"history\"] = \"history\";\r\n})(HistoryTypes || (HistoryTypes = {}));\r\nexport var HttpRockets;\r\n(function (HttpRockets) {\r\n    HttpRockets[\"beacon\"] = \"beacon\";\r\n    HttpRockets[\"fetch\"] = \"fetch\";\r\n    HttpRockets[\"xhr\"] = \"xhr\";\r\n})(HttpRockets || (HttpRockets = {}));\r\nexport var HttpEndTypes;\r\n(function (HttpEndTypes) {\r\n    HttpEndTypes[\"fetcherror\"] = \"fetcherror\";\r\n    HttpEndTypes[\"xhrerror\"] = \"xhrerror\";\r\n    HttpEndTypes[\"xhrabort\"] = \"xhrabort\";\r\n    HttpEndTypes[\"xhrtimeout\"] = \"xhrtimeout\";\r\n})(HttpEndTypes || (HttpEndTypes = {}));\r\nexport var ErrorTypes;\r\n(function (ErrorTypes) {\r\n    ErrorTypes[\"jserr\"] = \"jserr\";\r\n    ErrorTypes[\"unhandledrejection\"] = \"unhandledrejection\";\r\n})(ErrorTypes || (ErrorTypes = {}));\r\nexport var DOMMutationTypes;\r\n(function (DOMMutationTypes) {\r\n    DOMMutationTypes[\"attr\"] = \"attr\";\r\n    DOMMutationTypes[\"node\"] = \"node\";\r\n    DOMMutationTypes[\"text\"] = \"text\"; // text change\r\n})(DOMMutationTypes || (DOMMutationTypes = {}));\r\n","import { __assign, __extends } from \"tslib\";\r\nimport { _throttle, _log, _warn } from '../tools/helpers';\r\nimport SonyA7R3 from '../tools/SonyA7R3';\r\nimport { RECORDER_PRESET } from '../constants';\r\nimport { EventTypes } from '../models/observers';\r\nimport EventDrivenable from '../tools/pub-sub';\r\nvar getRecordIdByElement = SonyA7R3.getRecordIdByElement;\r\n/**\r\n * Observe scroll, window resize, form field value change(input/textarea/radio etc.)\r\n * and produce an Record\r\n */\r\nvar EventObserver = /** @class */ (function (_super) {\r\n    __extends(EventObserver, _super);\r\n    function EventObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.listeners = [];\r\n        _this.options = RECORDER_PRESET.event;\r\n        /**\r\n         * @param option useCapture or AddEventListenerOptions\r\n         */\r\n        _this.addListener = function (_a, cb) {\r\n            var target = _a.target, event = _a.event, callback = _a.callback, options = _a.options;\r\n            target.addEventListener(event, callback, options);\r\n            _this.listeners.push({\r\n                target: target,\r\n                event: event,\r\n                callback: callback\r\n            });\r\n            try {\r\n                cb && cb();\r\n            }\r\n            catch (err) {\r\n                _warn(err);\r\n            }\r\n        };\r\n        // Provide that document's direction is `rtl`(default)\r\n        _this.getScrollPosition = function () {\r\n            // Quirks mode on the contrary\r\n            var isStandardsMode = document.compatMode === 'CSS1Compat';\r\n            var x = isStandardsMode ? document.documentElement.scrollLeft : document.body.scrollLeft;\r\n            var y = isStandardsMode ? document.documentElement.scrollTop : document.body.scrollTop;\r\n            return { x: x, y: y };\r\n        };\r\n        _this.getScrollRecord = function (evt) {\r\n            var target = (evt || { target: document }).target;\r\n            var $emit = _this.$emit;\r\n            var record = { type: EventTypes.scroll };\r\n            // 1. target is docuemnt\r\n            // 2. No event invoking\r\n            if (target === document || !target) {\r\n                var _a = _this.getScrollPosition(), x_1 = _a.x, y_1 = _a.y;\r\n                record = __assign(__assign({}, record), { x: x_1, y: y_1 });\r\n                $emit('observed', record);\r\n                return;\r\n            }\r\n            var targetX = target;\r\n            var x = targetX.scrollLeft, y = targetX.scrollTop;\r\n            var recorderId = getRecordIdByElement(targetX);\r\n            record = __assign(__assign({}, record), { x: x, y: y, target: recorderId });\r\n            $emit('observed', record);\r\n        };\r\n        _this.getResizeRecord = function () {\r\n            var _a = document.documentElement, w = _a.clientWidth, h = _a.clientHeight;\r\n            var record = { type: EventTypes.resize, w: w, h: h };\r\n            var $emit = _this.$emit;\r\n            $emit('observed', record);\r\n        };\r\n        _this.getFormChangeRecord = function (evt) {\r\n            var target = evt.target;\r\n            if (target.contentEditable === 'true') {\r\n                return;\r\n            }\r\n            var recorderId = getRecordIdByElement(target);\r\n            var k;\r\n            var v;\r\n            if (!recorderId)\r\n                return;\r\n            var itemsWhichKeyIsChecked = ['radio', 'checked'];\r\n            var targetX = target;\r\n            var formType = targetX.type;\r\n            if (itemsWhichKeyIsChecked.includes(formType)) {\r\n                k = 'checked';\r\n                v = targetX.checked;\r\n            }\r\n            else {\r\n                k = 'value';\r\n                v = targetX.value;\r\n            }\r\n            var record = {\r\n                type: EventTypes.form,\r\n                target: recorderId,\r\n                k: k,\r\n                v: v\r\n            };\r\n            var $emit = _this.$emit;\r\n            $emit('observed', record);\r\n        };\r\n        if (typeof options === 'boolean' && options === false) {\r\n            return _this;\r\n        }\r\n        if (typeof options === 'object') {\r\n            _this.options = __assign(__assign({}, _this.options), options);\r\n        }\r\n        return _this;\r\n    }\r\n    EventObserver.prototype.install = function () {\r\n        var addListener = this.addListener;\r\n        var _a = this.options, scroll = _a.scroll, resize = _a.resize, form = _a.form;\r\n        if (scroll) {\r\n            addListener({\r\n                target: document,\r\n                event: 'scroll',\r\n                callback: this.getScrollRecord,\r\n                options: true\r\n            });\r\n        }\r\n        if (resize) {\r\n            addListener({\r\n                target: window,\r\n                event: 'resize',\r\n                callback: _throttle(this.getResizeRecord)\r\n            });\r\n        }\r\n        if (form) {\r\n            addListener({\r\n                target: document,\r\n                event: 'change',\r\n                callback: this.getFormChangeRecord,\r\n                options: true\r\n            });\r\n            // input event fires when value of <input> <select> <textarea> element has been altered.\r\n            addListener({\r\n                target: document,\r\n                event: 'input',\r\n                callback: _throttle(this.getFormChangeRecord, 300),\r\n                options: true\r\n            });\r\n        }\r\n        _log('events observer ready!');\r\n    };\r\n    EventObserver.prototype.uninstall = function () {\r\n        this.listeners.forEach(function (_a) {\r\n            var target = _a.target, event = _a.event, callback = _a.callback;\r\n            target.removeEventListener(event, callback);\r\n        });\r\n    };\r\n    return EventObserver;\r\n}(EventDrivenable));\r\nexport default EventObserver;\r\n","import { __assign, __extends, __read, __spread } from \"tslib\";\r\nimport { _replace, _recover, _newuuid, _log, _warn } from '../tools/helpers';\r\nimport { isFunction } from '../tools/is';\r\nimport { RECORDER_PRESET } from '../constants';\r\nimport EventDrivenable from '../tools/pub-sub';\r\nimport { HttpRockets } from '../models/observers';\r\nvar HttpObserver = /** @class */ (function (_super) {\r\n    __extends(HttpObserver, _super);\r\n    function HttpObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.options = RECORDER_PRESET.http;\r\n        _this.xhrRecordMap = new Map();\r\n        if (typeof options === 'boolean' && options === false) {\r\n            return _this;\r\n        }\r\n        if (typeof options === 'object') {\r\n            _this.options = __assign(__assign({}, _this.options), options);\r\n        }\r\n        return _this;\r\n    }\r\n    HttpObserver.prototype.isSupportBeacon = function () {\r\n        return !!navigator.sendBeacon;\r\n    };\r\n    HttpObserver.prototype.hijackBeacon = function () {\r\n        if (!this.isSupportBeacon())\r\n            return;\r\n        var $emit = this.$emit;\r\n        function beaconReplacement(originalBeacon) {\r\n            return function (url, data) {\r\n                // Copy from sentry javascript\r\n                // If the browser successfully queues the request for delivery, the method returns \"true\" and returns \"false\" otherwise.\r\n                // more: https://developer.mozilla.org/en-US/docs/Web/API/Beacon_API/Using_the_Beacon_API\r\n                var result = originalBeacon.call(this, url, data);\r\n                var record = {\r\n                    type: HttpRockets.beacon,\r\n                    url: url\r\n                };\r\n                $emit('observed', record);\r\n                return result;\r\n            };\r\n        }\r\n        _replace(window.navigator, 'sendBeacon', beaconReplacement);\r\n    };\r\n    HttpObserver.prototype.isSupportFetch = function () {\r\n        return window.fetch && window.fetch.toString().includes('native');\r\n    };\r\n    HttpObserver.prototype.hijackFetch = function () {\r\n        if (!this.isSupportFetch())\r\n            return;\r\n        var $emit = this.$emit;\r\n        function fetchReplacement(originalFetch) {\r\n            return function (input, config) {\r\n                var _method = 'GET';\r\n                var _url;\r\n                if (typeof input === 'string') {\r\n                    _url = input;\r\n                }\r\n                else if (input instanceof Request) {\r\n                    var method = input.method, url = input.url;\r\n                    _url = url;\r\n                    if (method)\r\n                        _method = method;\r\n                }\r\n                else {\r\n                    _url = String(input);\r\n                }\r\n                if (config && config.method) {\r\n                    _method = config.method;\r\n                }\r\n                var record = {\r\n                    type: HttpRockets.fetch,\r\n                    method: _method,\r\n                    url: _url,\r\n                    input: __spread(arguments)\r\n                };\r\n                return (originalFetch\r\n                    .call.apply(originalFetch, __spread([window], arguments)).then(function (response) {\r\n                    try {\r\n                        record.status = response.status;\r\n                        record.response = response.clone().json();\r\n                        $emit('observed', record);\r\n                    }\r\n                    catch (err) {\r\n                        _warn(err);\r\n                    }\r\n                    return response;\r\n                })\r\n                    .catch(function (error) {\r\n                    var message = error.message;\r\n                    record.errmsg = message;\r\n                    $emit('observed', record);\r\n                    throw error;\r\n                }));\r\n            };\r\n        }\r\n        _replace(window, 'fetch', fetchReplacement);\r\n    };\r\n    HttpObserver.prototype.hijackXHR = function () {\r\n        var $emit = this.$emit;\r\n        var self = this;\r\n        function XHROpenReplacement(originalOpen) {\r\n            return function (method, url) {\r\n                var requestId = _newuuid();\r\n                var args = __spread(arguments);\r\n                var record = {\r\n                    type: HttpRockets.xhr,\r\n                    url: url,\r\n                    method: method,\r\n                    headers: {}\r\n                };\r\n                this.__id__ = requestId;\r\n                self.xhrRecordMap.set(requestId, record);\r\n                return originalOpen.apply(this, args);\r\n            };\r\n        }\r\n        function XHRSetRequestHeaderReplacement(originalSetter) {\r\n            return function (key, value) {\r\n                var requestId = this.__id__;\r\n                var record = self.xhrRecordMap.get(requestId);\r\n                if (record) {\r\n                    record.headers[key] = value;\r\n                }\r\n                originalSetter.call(this, key, value);\r\n            };\r\n        }\r\n        function XHRSendReplacement(originalSend) {\r\n            return function (body) {\r\n                var thisXHR = this;\r\n                var requestId = thisXHR.__id__, __skip_record__ = thisXHR.__skip_record__;\r\n                var thisRecord = self.xhrRecordMap.get(requestId);\r\n                // skip recorder's own request\r\n                if (thisRecord && !__skip_record__) {\r\n                    thisRecord.payload = body;\r\n                }\r\n                function onreadystatechangeHandler() {\r\n                    if (this.readyState === 4) {\r\n                        if (this.__skip_record__)\r\n                            return;\r\n                        var record = self.xhrRecordMap.get(requestId);\r\n                        if (record) {\r\n                            record.status = thisXHR.status;\r\n                            // if the responseType is neither 'text' nor ''\r\n                            // read responseText would produce an error\r\n                            if (thisXHR.responseType === '' || thisXHR.responseType === 'text') {\r\n                                record.response = thisXHR.responseText || thisXHR.response;\r\n                            }\r\n                            else {\r\n                                record.response = thisXHR.responseType;\r\n                            }\r\n                            // xhr send successfully\r\n                            $emit('observed', record);\r\n                        }\r\n                    }\r\n                }\r\n                // TODO: hijack xhr.onerror, xhr.onabort, xhr.ontimeout\r\n                if ('onreadystatechange' in thisXHR && isFunction(thisXHR.onreadystatechange)) {\r\n                    // if already had a hook\r\n                    _replace(thisXHR, 'onreadystatechange', function (originalStateChangeHook) {\r\n                        return function () {\r\n                            var args = [];\r\n                            for (var _i = 0; _i < arguments.length; _i++) {\r\n                                args[_i] = arguments[_i];\r\n                            }\r\n                            try {\r\n                                onreadystatechangeHandler.call(thisXHR);\r\n                            }\r\n                            catch (err) {\r\n                                _warn(err);\r\n                            }\r\n                            originalStateChangeHook.call.apply(originalStateChangeHook, __spread([thisXHR], args));\r\n                        };\r\n                    });\r\n                }\r\n                else {\r\n                    thisXHR.onreadystatechange = onreadystatechangeHandler;\r\n                }\r\n                try {\r\n                    return originalSend.call(this, body);\r\n                }\r\n                catch (exception) {\r\n                    // if an exception occured after send, count in thisXHR\r\n                    var message = exception.message;\r\n                    var record = self.xhrRecordMap.get(requestId);\r\n                    if (record) {\r\n                        record.errmsg = message;\r\n                        // xhr send error\r\n                        $emit('observed', record);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        var XHRProto = XMLHttpRequest.prototype;\r\n        _replace(XHRProto, 'setRequestHeader', XHRSetRequestHeaderReplacement);\r\n        _replace(XHRProto, 'open', XHROpenReplacement);\r\n        _replace(XHRProto, 'send', XHRSendReplacement);\r\n    };\r\n    HttpObserver.prototype.install = function () {\r\n        var _a = this.options, beacon = _a.beacon, fetch = _a.fetch, xhr = _a.xhr;\r\n        if (beacon) {\r\n            this.hijackBeacon();\r\n        }\r\n        if (fetch) {\r\n            this.hijackFetch();\r\n        }\r\n        if (xhr) {\r\n            this.hijackXHR();\r\n        }\r\n        _log('http observer ready!');\r\n    };\r\n    HttpObserver.prototype.uninstall = function () {\r\n        var _a = this.options, beacon = _a.beacon, fetch = _a.fetch, xhr = _a.xhr;\r\n        if (beacon) {\r\n            _recover(window.navigator, 'sendBeacon');\r\n        }\r\n        if (fetch) {\r\n            _recover(window, 'fetch');\r\n        }\r\n        if (xhr) {\r\n            this.hijackBeacon();\r\n        }\r\n    };\r\n    return HttpObserver;\r\n}(EventDrivenable));\r\nexport default HttpObserver;\r\n","import { __extends, __values } from \"tslib\";\r\nimport { RECORDER_ID } from '../constants';\r\nimport SonyA7R3 from '../tools/SonyA7R3';\r\nimport { _log, _warn } from '../tools/helpers';\r\nimport EventDrivenable from '../tools/pub-sub';\r\nimport { DOMMutationTypes } from '../models/observers';\r\nvar getRecordIdByElement = SonyA7R3.getRecordIdByElement;\r\n/**\r\n * Observe DOM change such as DOM-add/remove text-change attribute-change\r\n * and generate an Record\r\n */\r\nvar DOMMutationObserver = /** @class */ (function (_super) {\r\n    __extends(DOMMutationObserver, _super);\r\n    function DOMMutationObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        if (options === false)\r\n            return _this;\r\n        return _this;\r\n    }\r\n    DOMMutationObserver.prototype.process = function (mutationRecord) {\r\n        try {\r\n            var target = mutationRecord.target, attributeName = mutationRecord.attributeName;\r\n            // ignore script tag's mutation\r\n            if (target && target.tagName === 'SCRIPT')\r\n                return;\r\n            switch (mutationRecord.type) {\r\n                case 'attributes': {\r\n                    // ignore recorderId mutate\r\n                    if (attributeName === RECORDER_ID)\r\n                        return;\r\n                    return this.getAttrReocrd(mutationRecord);\r\n                }\r\n                case 'characterData': {\r\n                    return this.getTextRecord(mutationRecord);\r\n                }\r\n                case 'childList': {\r\n                    return this.getNodesRecord(mutationRecord);\r\n                }\r\n                default: {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            _warn(error);\r\n        }\r\n    };\r\n    // when node's attribute change\r\n    DOMMutationObserver.prototype.getAttrReocrd = function (_a) {\r\n        var attributeName = _a.attributeName, target = _a.target;\r\n        var record = { attr: {} };\r\n        record.target = getRecordIdByElement(target);\r\n        if (record.target === undefined)\r\n            return;\r\n        record.type = DOMMutationTypes.attr;\r\n        record.attr.k = attributeName;\r\n        record.attr.v = target.getAttribute(attributeName);\r\n        return record;\r\n    };\r\n    // when textNode's innerText change\r\n    DOMMutationObserver.prototype.getTextRecord = function (_a) {\r\n        var target = _a.target;\r\n        var record = {};\r\n        record.type = DOMMutationTypes.text;\r\n        record.target = getRecordIdByElement(target);\r\n        /**\r\n         * 比如文本修改是在一个 contenteditable 的 `元素A` 内发生，\r\n         * 并且 `元素A` 内有 textNode 和 element 同时存在，\r\n         * 当只修改某个 textNode 时，MutationObserver 给的 target 会指向这个 textNode，\r\n         * 所以 record.target 在上面代码中 getRecordIdByElement 时会取到 undefined (因为 document bufferer 字典内只缓存 element)，\r\n         * 这时我们将 record.target 指向 `元素A` ，\r\n         * record.html 取 `元素A` 的 innerHTML。\r\n         * --------------------------------------------------------------------------------------------------\r\n         * When the mutation happen with contenteditable `elementA` which contains textNodes and element inside,\r\n         * NOTE that MutationObserver will point the `target` to the textNode we modified,\r\n         * therefore, we should get undefined of `getRecordIdByElement(target)` (since document bufferer didn't buffer textNode).\r\n         * So we manually set record.target = `elementA`,\r\n         * and record.html = elementA.innerHTML at the same time\r\n         */\r\n        if (!record.target) {\r\n            var parentEle = getRecordIdByElement(target.parentElement);\r\n            /**\r\n             * 如果这时候取不到 parentEle 或者 target.parentElement 为 null，则视该条记录作废\r\n             * 这种情况会在删除整个 textNode 时发生，可以忽略，\r\n             * 因为这个动作会额外的生成一个类型为 childList 的 MutationRecord\r\n             * 交给 this.getNodesRecord 处理就好\r\n             * ----------------------------------------------------------------\r\n             * if (parentEle === null), means the textNode has been removed,\r\n             * this mutation would produce a MutationRecord with type === 'childList',\r\n             * just leave it to this.getNodesRecord to handle :)\r\n             */\r\n            if (!parentEle) {\r\n                return;\r\n            }\r\n            record.target = parentEle;\r\n            record.html = target.parentElement.innerHTML;\r\n        }\r\n        else {\r\n            // use textContent instend of innerText(non-standard),\r\n            // see also https://stackoverflow.com/questions/35213147/difference-between-textcontent-vs-innertext\r\n            record.text = target.textContent;\r\n        }\r\n        return record;\r\n    };\r\n    /**\r\n     * @Either:\r\n     * if node been added or removed,\r\n     * @Or:\r\n     * if a contenteditable textNode's text been all removed, type should be `childList`(remove #text),\r\n     * later if you type/add some text in this empty textNode, the first mutation's type would be `childList`(add #text), fellows by `characterData`s\r\n     */\r\n    DOMMutationObserver.prototype.getNodesRecord = function (_a) {\r\n        var _this = this;\r\n        var target = _a.target, addedNodes = _a.addedNodes, removedNodes = _a.removedNodes, previousSibling = _a.previousSibling, nextSibling = _a.nextSibling;\r\n        var record = { add: [], remove: [] };\r\n        record.target = getRecordIdByElement(target);\r\n        if (previousSibling) {\r\n            record.prev = getRecordIdByElement(previousSibling);\r\n        }\r\n        if (nextSibling) {\r\n            record.next = getRecordIdByElement(nextSibling);\r\n        }\r\n        /** ------------------------------ Add or Remove nodes --------------------------------- */\r\n        var isAdd = addedNodes.length;\r\n        var isRemove = removedNodes.length;\r\n        if (!isAdd && !isRemove)\r\n            return;\r\n        // add and remove node could happen in the same record\r\n        record.type = DOMMutationTypes.node;\r\n        // Add element or textNode\r\n        this.nodesFilter(addedNodes).forEach(function (node) {\r\n            var nodeData = {};\r\n            switch (node.nodeName) {\r\n                case '#text': {\r\n                    nodeData.type = 'text';\r\n                    // add textNode\r\n                    // nodeValue: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue\r\n                    nodeData.html = node.nodeValue;\r\n                    if (target.childNodes.length) {\r\n                        nodeData.index = _this.getNodeIndex(node.parentElement, node);\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    nodeData.type = 'ele';\r\n                    var parentElement = node.parentElement, nodeValue = node.nodeValue;\r\n                    if (!parentElement) {\r\n                        // in case the node was the <html> element\r\n                        nodeData.html = nodeValue || node.outerHTML;\r\n                        break;\r\n                    }\r\n                    nodeData.index = _this.getNodeIndex(parentElement, node);\r\n                    SonyA7R3.bufferNewElement(node);\r\n                    nodeData.html = node.outerHTML;\r\n                    SonyA7R3.unmark(node, true);\r\n                }\r\n            }\r\n            if (nodeData.html === null)\r\n                return;\r\n            record.add.push(nodeData);\r\n        });\r\n        // Remove element or textNode\r\n        this.nodesFilter(removedNodes).forEach(function (node) {\r\n            var nodeData = {};\r\n            switch (node.nodeName) {\r\n                case '#text': {\r\n                    nodeData.type = 'text';\r\n                    var parentElement = node.parentElement;\r\n                    // 当删除一个 textNode 或 所有文本内容时\r\n                    // when delete the whole textNode\r\n                    if (parentElement) {\r\n                        nodeData.html = node.textContent;\r\n                        nodeData.index = Array.prototype.slice.call(parentElement.childNodes).indexOf(node);\r\n                    }\r\n                    else {\r\n                        // 在没有 parentElement 的情况下我们无法获取到这个 textNode 节点的 index\r\n                        // 这时我们只能记录下它的 textContent 然后通过前后元素来辅助定位，这个步骤在播放器里进行\r\n                        // on this occasion, we have no parentElement help us find\r\n                        // the index of node which was been removed,\r\n                        // we could only record the textContent and use previousSibling and nextSibling\r\n                        // for locating this node's index!   eg.[...prev, ->node<-, next...]\r\n                        nodeData.textContent = node.textContent;\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    nodeData.type = 'ele';\r\n                    nodeData.target = getRecordIdByElement(node);\r\n                    if (nodeData.target === undefined)\r\n                        return;\r\n                }\r\n            }\r\n            record.remove.push(nodeData);\r\n        });\r\n        // filter record which's addNodes and removeNode only contain SCRIPT or COMMENT\r\n        if (!record.remove.length && !record.add.length)\r\n            return;\r\n        if (record.target === undefined)\r\n            return;\r\n        if (!record.remove.length) {\r\n            delete record.remove;\r\n        }\r\n        if (!record.add.length) {\r\n            delete record.add;\r\n        }\r\n        return record;\r\n    };\r\n    // filter out comment and script\r\n    DOMMutationObserver.prototype.nodesFilter = function (nodeList) {\r\n        return Array.prototype.slice.call(nodeList).filter(function (node) {\r\n            var _a = node, nodeName = _a.nodeName, tagName = _a.tagName;\r\n            return nodeName !== '#comment' && tagName !== 'SCRIPT';\r\n        });\r\n    };\r\n    // get index of the node, attention that .childNodes return textNodes also\r\n    DOMMutationObserver.prototype.getNodeIndex = function (parentElement, node) {\r\n        return Array.prototype.slice.call(parentElement.childNodes).indexOf(node);\r\n    };\r\n    DOMMutationObserver.prototype.install = function () {\r\n        var _this = this;\r\n        var mutationObserver = window.MutationObserver || window.WebKitMutationObserver;\r\n        this.observer = new mutationObserver(function (records) {\r\n            var e_1, _a;\r\n            var $emit = _this.$emit;\r\n            try {\r\n                for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {\r\n                    var record = records_1_1.value;\r\n                    var DOMMutationRecord = _this.process(record);\r\n                    if (DOMMutationRecord) {\r\n                        $emit('observed', DOMMutationRecord);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        });\r\n        this.observer.observe(document.documentElement, {\r\n            attributes: true,\r\n            childList: true,\r\n            characterData: true,\r\n            subtree: true\r\n        });\r\n        _log('mutation observer ready!');\r\n    };\r\n    DOMMutationObserver.prototype.uninstall = function () {\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n            this.observer = null;\r\n        }\r\n    };\r\n    return DOMMutationObserver;\r\n}(EventDrivenable));\r\nexport default DOMMutationObserver;\r\n","import { __assign, __extends } from \"tslib\";\r\nimport { _replace, _log, _recover } from '../tools/helpers';\r\nimport { RECORDER_PRESET } from '../constants';\r\nimport EventDrivenable from '../tools/pub-sub';\r\nimport { ErrorTypes } from '../models/observers';\r\nvar ErrorObserver = /** @class */ (function (_super) {\r\n    __extends(ErrorObserver, _super);\r\n    function ErrorObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.options = RECORDER_PRESET.error;\r\n        _this.getGlobalerrorReocrd = function (errevt) {\r\n            var msg = errevt.message, lineno = errevt.lineno, colno = errevt.colno, err = errevt.error, url = errevt.filename;\r\n            var record = {\r\n                type: ErrorTypes.jserr,\r\n                url: url,\r\n                line: lineno + \":\" + colno,\r\n                msg: msg,\r\n                err: err,\r\n                stack: err.stack\r\n            };\r\n            var $emit = _this.$emit;\r\n            $emit('observed', record, errevt);\r\n        };\r\n        _this.getUnhandlerejectionRecord = function (errevt) {\r\n            var reason = errevt.reason || '';\r\n            var record = {\r\n                type: ErrorTypes.unhandledrejection,\r\n                msg: reason,\r\n                stack: reason.stack\r\n            };\r\n            var $emit = _this.$emit;\r\n            $emit('observed', record, errevt);\r\n        };\r\n        if (typeof options === 'boolean' && options === false) {\r\n            return _this;\r\n        }\r\n        if (typeof options === 'object') {\r\n            _this.options = __assign(__assign({}, _this.options), options);\r\n        }\r\n        return _this;\r\n    }\r\n    // TODO: generate stack of an error which is acceptable for sentry\r\n    ErrorObserver.prototype.getStackTeace = function () {\r\n        /* TODO */\r\n    };\r\n    ErrorObserver.prototype.installGlobalerrorHandler = function () {\r\n        var getGlobalerrorReocrd = this.getGlobalerrorReocrd;\r\n        _replace(window, 'onerror', function (oldOnerrorHandler) {\r\n            var recorderOnerrorHandler = function (message, filename, lineno, colno, error) {\r\n                /**\r\n                 * \"For historical reasons, different arguments are passed to window.onerror and element.onerror handlers\"\r\n                 *  more: - https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror\r\n                 *       - https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#Syntax\r\n                 */\r\n                if (error && error instanceof ErrorEvent) {\r\n                    getGlobalerrorReocrd(error);\r\n                }\r\n                else if (message instanceof ErrorEvent) {\r\n                    getGlobalerrorReocrd(message);\r\n                }\r\n                else {\r\n                    getGlobalerrorReocrd({\r\n                        message: message,\r\n                        filename: filename,\r\n                        lineno: lineno,\r\n                        colno: colno,\r\n                        error: error\r\n                    });\r\n                }\r\n                if (oldOnerrorHandler) {\r\n                    // TODO: find approximate \"this\" scope for oldOnerrorHandler - not window\r\n                    oldOnerrorHandler.apply(window, arguments);\r\n                }\r\n            };\r\n            return recorderOnerrorHandler;\r\n        });\r\n    };\r\n    ErrorObserver.prototype.installUnhanldledrejectionHandler = function () {\r\n        var getUnhandlerejectionRecord = this.getUnhandlerejectionRecord;\r\n        _replace(window, 'onunhandledrejection', function (originalUnhanldledrejectionHandler) {\r\n            // more: https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onunhandledrejection\r\n            return function (errevt) {\r\n                getUnhandlerejectionRecord(errevt);\r\n                if (originalUnhanldledrejectionHandler) {\r\n                    originalUnhanldledrejectionHandler.call(this, errevt);\r\n                }\r\n            };\r\n        });\r\n    };\r\n    ErrorObserver.prototype.install = function () {\r\n        var _a = this.options, jserror = _a.jserror, unhandledrejection = _a.unhandledrejection;\r\n        if (jserror) {\r\n            this.installGlobalerrorHandler();\r\n            // TODO: protect recorder's onerror hook by defineProperty\r\n            Object.defineProperty(window, 'onerror', {\r\n                set: function (newHook) {\r\n                    if (!newHook.__recorder__) {\r\n                        _log('recorder error handler died!');\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (unhandledrejection) {\r\n            this.installUnhanldledrejectionHandler();\r\n        }\r\n        _log('error observer ready!');\r\n    };\r\n    ErrorObserver.prototype.uninstall = function () {\r\n        var _a = this.options, jserror = _a.jserror, unhandledrejection = _a.unhandledrejection;\r\n        if (jserror) {\r\n            _recover(window, 'onerror');\r\n        }\r\n        if (unhandledrejection) {\r\n            _recover(window, 'onunhandledrejection');\r\n        }\r\n    };\r\n    return ErrorObserver;\r\n}(EventDrivenable));\r\nexport default ErrorObserver;\r\n","import { __extends } from \"tslib\";\r\nimport { _recover, _log, _parseURL, _replace } from '../tools/helpers';\r\nimport EventDrivenable from '../tools/pub-sub';\r\nimport { HistoryTypes } from '../models/observers';\r\nvar HistoryObserver = /** @class */ (function (_super) {\r\n    __extends(HistoryObserver, _super);\r\n    function HistoryObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.status = false;\r\n        if (options === false)\r\n            return _this;\r\n        return _this;\r\n    }\r\n    HistoryObserver.prototype.getHistoryRecord = function (from, to) {\r\n        var parsedHref = _parseURL(location.href);\r\n        var parsedTo = _parseURL(to);\r\n        var parsedFrom = _parseURL(from);\r\n        // Initial pushState doesn't provide `from` information\r\n        if (!parsedFrom.path) {\r\n            parsedFrom = parsedHref;\r\n        }\r\n        this.lastHref = to;\r\n        var record = {\r\n            type: HistoryTypes.history,\r\n            from: parsedFrom.relative,\r\n            to: parsedTo.relative\r\n        };\r\n        var $emit = this.$emit;\r\n        $emit('observed', record);\r\n    };\r\n    HistoryObserver.prototype.isSupportHistory = function () {\r\n        return 'history' in window && !!window.history.pushState && !!window.history.replaceState;\r\n    };\r\n    HistoryObserver.prototype.install = function () {\r\n        if (!this.isSupportHistory())\r\n            return;\r\n        var getHistoryRecord = this.getHistoryRecord;\r\n        var self = this;\r\n        _replace(window, 'onpopstate', function (originalHandler) {\r\n            return function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                getHistoryRecord.call(self, self.lastHref, location.href);\r\n                originalHandler && originalHandler.apply(this, args);\r\n            };\r\n        });\r\n        function historyReplacement(originalMethod) {\r\n            return function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                var url = args.length > 2 ? args[2] : undefined;\r\n                if (url)\r\n                    getHistoryRecord.call(self, self.lastHref, String(url));\r\n                return originalMethod.apply(this, args);\r\n            };\r\n        }\r\n        _replace(window.history, 'pushState', historyReplacement);\r\n        _replace(window.history, 'replaceState', historyReplacement);\r\n        _log('history installed');\r\n        this.status = true;\r\n    };\r\n    HistoryObserver.prototype.uninstall = function () {\r\n        _recover(window, 'onpopstate');\r\n        _recover(window.history, 'pushState');\r\n        _recover(window.history, 'replaceState');\r\n        this.status = false;\r\n    };\r\n    return HistoryObserver;\r\n}(EventDrivenable));\r\nexport default HistoryObserver;\r\n","import { __assign, __extends } from \"tslib\";\r\nimport { MouseTypes } from '../models/observers';\r\nimport { _throttle, _log, _warn } from '../tools/helpers';\r\nimport { RECORDER_PRESET } from '../constants';\r\nimport EventDrivenable from '../tools/pub-sub';\r\n/**\r\n * Observe mouse behavior\r\n * and produce an Record\r\n */\r\nvar MouseObserver = /** @class */ (function (_super) {\r\n    __extends(MouseObserver, _super);\r\n    function MouseObserver(options) {\r\n        var _this = _super.call(this) || this;\r\n        _this.listeners = [];\r\n        _this.options = RECORDER_PRESET.mouse;\r\n        _this.addListener = function (_a, cb) {\r\n            var target = _a.target, event = _a.event, callback = _a.callback, _b = _a.options, options = _b === void 0 ? false : _b;\r\n            target.addEventListener(event, callback, options);\r\n            _this.listeners.push({\r\n                target: target,\r\n                event: event,\r\n                callback: callback\r\n            });\r\n            try {\r\n                cb && cb();\r\n            }\r\n            catch (err) {\r\n                _warn(err);\r\n            }\r\n        };\r\n        _this.getMouseClickRecord = function (evt) {\r\n            var x = evt.pageX, y = evt.pageY;\r\n            var record = { type: MouseTypes.click, x: x, y: y };\r\n            var $emit = _this.$emit;\r\n            $emit('observed', record);\r\n        };\r\n        _this.getMouseMoveRecord = function (evt) {\r\n            var x = evt.pageX, y = evt.pageY;\r\n            var record = { type: MouseTypes.move, x: x, y: y };\r\n            var $emit = _this.$emit;\r\n            $emit('observed', record);\r\n        };\r\n        if (typeof options === 'boolean' && options === false) {\r\n            return _this;\r\n        }\r\n        if (typeof options === 'object') {\r\n            _this.options = __assign(__assign({}, _this.options), options);\r\n        }\r\n        return _this;\r\n    }\r\n    MouseObserver.prototype.install = function () {\r\n        var addListener = this.addListener;\r\n        var _a = this.options, click = _a.click, mousemove = _a.mousemove;\r\n        if (click) {\r\n            addListener({\r\n                target: document,\r\n                event: 'click',\r\n                callback: this.getMouseClickRecord\r\n            });\r\n        }\r\n        if (mousemove) {\r\n            addListener({\r\n                target: document,\r\n                event: 'mousemove',\r\n                callback: _throttle(this.getMouseMoveRecord, 50)\r\n            });\r\n        }\r\n        _log('mouse observer ready!');\r\n    };\r\n    MouseObserver.prototype.uninstall = function () {\r\n        this.listeners.forEach(function (_a) {\r\n            var target = _a.target, event = _a.event, callback = _a.callback;\r\n            target.removeEventListener(event, callback);\r\n        });\r\n    };\r\n    return MouseObserver;\r\n}(EventDrivenable));\r\nexport default MouseObserver;\r\n","import { __assign } from \"tslib\";\r\nimport { _warn, _now, _throttle } from './tools/helpers';\r\nimport { RECORDER_PRESET } from './constants';\r\nimport ConsoleObserver from './observers/console';\r\nimport EventObserver from './observers/event';\r\nimport HttpObserver from './observers/http';\r\nimport DOMMutationObserver from './observers/mutation';\r\nimport ErrorObserver from './observers/error';\r\nimport HistoryObserver from './observers/history';\r\nimport MouseObserver from './observers/mouse';\r\nimport SonyA7R3 from './tools/SonyA7R3';\r\nvar SessionRecorder = /** @class */ (function () {\r\n    function SessionRecorder(options) {\r\n        var _this = this;\r\n        this.observers = {\r\n            mutation: null,\r\n            console: null,\r\n            event: null,\r\n            mouse: null,\r\n            error: null,\r\n            history: null,\r\n            http: null\r\n        };\r\n        this.options = RECORDER_PRESET;\r\n        this.trail = [];\r\n        this.recording = false;\r\n        this.baseTime = 0;\r\n        this.lastSnapshot = {\r\n            time: 0,\r\n            index: 0\r\n        };\r\n        this.observeScroll = function (ele) {\r\n            if (ele) {\r\n                ele.addEventListener('scroll', _throttle(_this.observers.event.getScrollRecord));\r\n            }\r\n            else {\r\n                _warn(\"Element doesn't existsed!\");\r\n            }\r\n        };\r\n        this.pushToTrail = function (record) {\r\n            if (!_this.recording)\r\n                return;\r\n            var thisRecordTime = _now() - _this.baseTime;\r\n            record = __assign({ t: thisRecordTime }, record);\r\n            var _a = _this.lastSnapshot, lastSnapshotTime = _a.time, lastSnapshotIndex = _a.index;\r\n            if (thisRecordTime - lastSnapshotTime >= _this.options.maxTimeSpan / 2) {\r\n                if (lastSnapshotIndex !== 0) {\r\n                    _this.trail = _this.trail.slice(lastSnapshotIndex);\r\n                }\r\n                var snapshotRecord = _this.getSnapshotRecord();\r\n                _this.trail.push(snapshotRecord);\r\n            }\r\n            _this.trail.push(record);\r\n        };\r\n        this.start = function () {\r\n            if (_this.recording) {\r\n                _warn('record already started');\r\n                return;\r\n            }\r\n            _this.recording = true;\r\n            _this.baseTime = _now();\r\n            // note the getSnapshotRecord method depend on baseTime\r\n            _this.trail[0] = _this.getSnapshotRecord();\r\n            Object.keys(_this.observers).forEach(function (observerName) {\r\n                if (_this.options[observerName]) {\r\n                    ;\r\n                    _this.observers[observerName].install();\r\n                }\r\n            });\r\n            window.SessionRecorder = _this;\r\n        };\r\n        this.stop = function () {\r\n            if (!_this.recording) {\r\n                _warn('record not started');\r\n                return;\r\n            }\r\n            _this.recording = false;\r\n            // clear trail\r\n            _this.trail.length = 0;\r\n        };\r\n        this.uninstallObservers = function () {\r\n            // walk and uninstall observers\r\n            Object.keys(_this.observers).forEach(function (observerName) {\r\n                ;\r\n                _this.observers[observerName].uninstall();\r\n            });\r\n        };\r\n        if (options && typeof options === 'object') {\r\n            this.options = __assign(__assign({}, this.options), options);\r\n        }\r\n        var _a = this.options, mutation = _a.mutation, history = _a.history, http = _a.http, event = _a.event, error = _a.error, consoleOptions = _a.console, mouse = _a.mouse;\r\n        this.observers = {\r\n            mutation: new DOMMutationObserver(mutation),\r\n            http: new HttpObserver(http),\r\n            console: new ConsoleObserver(consoleOptions),\r\n            event: new EventObserver(event),\r\n            mouse: new MouseObserver(mouse),\r\n            error: new ErrorObserver(error),\r\n            history: new HistoryObserver(history)\r\n        };\r\n        Object.keys(this.observers).forEach(function (observerName) {\r\n            var observer = _this.observers[observerName];\r\n            observer.$on('observed', _this.pushToTrail.bind(_this));\r\n        });\r\n        this.start();\r\n        setTimeout(function () {\r\n            console.log(JSON.stringify(_this.trail));\r\n        }, 5000);\r\n    }\r\n    SessionRecorder.prototype.getSnapshotRecord = function () {\r\n        this.lastSnapshot.time = _now() - (this.baseTime || _now());\r\n        this.lastSnapshot.index = this.trail.length;\r\n        var _a = document.documentElement, w = _a.clientWidth, h = _a.clientHeight;\r\n        var _b = this.observers.event.getScrollPosition(), x = _b.x, y = _b.y;\r\n        return {\r\n            t: this.lastSnapshot.time,\r\n            type: 'snapshot',\r\n            scroll: { x: x, y: y },\r\n            resize: {\r\n                w: w,\r\n                h: h\r\n            },\r\n            snapshot: SonyA7R3.takeSnapshotForPage()\r\n        };\r\n    };\r\n    return SessionRecorder;\r\n}());\r\nexport default SessionRecorder;\r\nnew SessionRecorder();\r\n"],"sourceRoot":""}